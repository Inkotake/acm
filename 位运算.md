## 位运算

### 异或技巧

> 异或理解为无进位相加

* swap
* max without if else
* 找缺少的数字
* 找奇数次出现数字
* 提取最右侧1的状态

```cpp
n &(-n)
```



* 返回出现小于m次的数

### 位运算

* 判断是否2的幂

```cpp
n &(-n) == n
```

* 判断是否3的幂

```cpp
3^k % n == 0
```

* 已知 $n >= 0$ 返回大于等于n的最小的2的幂 

```cpp
int min2pow(int n){
    if(n <= 0){
        return 1;
    }
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    .....
    return n  + 1;
}

用最左边的1把右边全部扫成1
00010000 -> 00011111 -> 00100000
```



* 区间 $[L,R]$ 内所有数字&的结果

  直接找lr公共前缀

  ```cpp
  eg:
  right 0101101101
        0101xxxxxx 从right--到left途中会把最右边的1消掉
  left  0101000101
  ```

* 反转（reverse）一个二进制，逆序

  ```cpp
  abcdefgh
  -> ba dc fe hg
  -> dc ba hg fe
  -> hg fe dc ba
      
    a b c d e f g h        a b c d e f g h
  & 1 0 1 0 1 0 1 0 =aa    0 1 0 1 0 1 0 1  =55        
    a 0 c 0 e 0 g 0 >> 1   0 b 0 d 0 f 0 h << 1
    0 a 0 c 0 e 0 g   +    b 0 d 0 f 0 h 0 
    b a d c f e h g        b a d c f e h g
  & 1 1 0 0 1 1 0 0 =bb    0 0 1 1 0 0 1 1  =33
    b a 0 0 f e 0 0 >>2    0 0 d c 0 0 h g <<2
    0 0 b a 0 0 f e  +     d c 0 0 h g 0 0
    d c b a h g f e        d c b a h g f e 
  & 1 1 1 1 0 0 0 0 =f0    0 0 0 0 1 1 1 1 = 0f
    d c b a 0 0 0 0 >>4    0 0 0 0 h g f e  << 4
    0 0 0 0 d c b a    +   h g f e 0 0 0 0
    h g f e d c b a
  #include <cstdint>
  
  int reverse(int x) {
      // 将输入转换为32位无符号整数进行位操作
      uint32_t ux = static_cast<uint32_t>(x);
      
      // 步骤1: 交换相邻的1位（使用掩码0xAAAAAAAA和0x55555555）
      ux = ((ux & UINT32_C(0xAAAAAAAA)) >> 1) | ((ux & UINT32_C(0x55555555)) << 1);
      
      // 步骤2: 交换相邻的2位（使用掩码0xCCCCCCCC和0x33333333）
      ux = ((ux & UINT32_C(0xCCCCCCCC)) >> 2) | ((ux & UINT32_C(0x33333333)) << 2);
      
      // 步骤3: 交换相邻的4位（使用掩码0xF0F0F0F0和0x0F0F0F0F）
      ux = ((ux & UINT32_C(0xF0F0F0F0)) >> 4) | ((ux & UINT32_C(0x0F0F0F0F)) << 4);
      
      // 步骤4: 交换相邻的8位（使用掩码0xFF00FF00和0x00FF00FF）
      ux = ((ux & UINT32_C(0xFF00FF00)) >> 8) | ((ux & UINT32_C(0x00FF00FF)) << 8);
      
      // 步骤5: 交换相邻的16位（使用掩码0xFFFF0000和0x0000FFFF）
      ux = ((ux & UINT32_C(0xFFFF0000)) >> 16) | ((ux & UINT32_C(0x0000FFFF)) << 16);
      
      // 将结果转换回有符号int返回（注意：位反转后值可能超出int范围，但位模式正确）
      return static_cast<int>(ux);
  }
  
  ```

  

* 返回一个二进制有几个1

  ```cpp
  #include <cstdint>
  
  int popcount(int x) {
      // 将输入转换为32位无符号整数进行位操作
      uint32_t ux = static_cast<uint32_t>(x);
      
      // 步骤1: 每2位一组，计算每组中1的个数（掩码0x55555555隔离每组的低位）
      ux = (ux & UINT32_C(0x55555555)) + ((ux >> 1) & UINT32_C(0x55555555));
      
      // 步骤2: 每4位一组，计算每组中1的个数（掩码0x33333333隔离每组的低2位）
      ux = (ux & UINT32_C(0x33333333)) + ((ux >> 2) & UINT32_C(0x33333333));
      
      // 步骤3: 每8位一组，计算每组中1的个数（掩码0x0F0F0F0F隔离每组的低4位）
      ux = (ux & UINT32_C(0x0F0F0F0F)) + ((ux >> 4) & UINT32_C(0x0F0F0F0F));
      
      // 步骤4: 每16位一组，计算每组中1的个数（掩码0x00FF00FF隔离每组的低8位）
      ux = (ux & UINT32_C(0x00FF00FF)) + ((ux >> 8) & UINT32_C(0x00FF00FF));
      
      // 步骤5: 每32位一组，计算每组中1的个数（掩码0x0000FFFF隔离低16位）
      ux = (ux & UINT32_C(0x0000FFFF)) + ((ux >> 16) & UINT32_C(0x0000FFFF));
      
      // 结果就是1的个数，直接返回
      return static_cast<int>(ux);
  }
  
  ```

  

## 位图

>  0-100的数字集合，只需要四个int表示，每个32位，一个bit表示一个数字,int[4]
>
> 以35位例，35/32 = 1， 35 %32 = 3, 状态为int\[1][3]

位图 $bitset(n)$ 储存 $1-n$ 的数字，实现add remove reverse方法 

> 实现向上取整 $(a  + b - 1) / b$ 