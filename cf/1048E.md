### 解析

现在已经处理好了
设 $k$ 为零的数量

对于树，按照层宽度分布，每一层的宽度为 $w_i$，形成一个背包问题

最短叶子节点所在层下标设为 $c$

把最短叶子节点之前的每一层的 $wide$拿来装背包
,已知零的数量为 $k$
$$
1 <= k <= n < 2\times10^5
$$
我们要让零可以填满某几个层，由于我们只要填$i <= c$的层，所以对于 $i > c $ 的层，总共假设有 $d$ 个顶点，我们可以用来当缓冲，用于把需要用来填的 $0$ 的数量变成一个范围，也就是说最少填 $ min(0, abs(k -d ))$ 个，最多填 $k$ 个


我们要做的是，确保 一个或多个$w_i$的和 $W$ 可以组合出0到$k$之间的某个数，也就是说
$$
W \in [min(0, abs(k -d )),k]
$$
正常来说，我们可以直接用背包做，题意转化为对于一个容量为 $x$的背包， 现在有 $c$ 个物品， 每个物品的重量是 $w_i$ , 问对于范围内的 $W$, 背包的容量，能否存在一个容量为 $x$ 的背包使得背包被占满， 也就是以下条件成立
$$
x\in[min(0, abs(k -d )),k]
$$
但是对于题目所给的数据范围，使用普通的01背包方法复杂度会来到 $O(nk)$

为此，我们需要一些优化方法,我们从两个角度出发，第一个是优化背包的复杂度，然后是对数据分治。


**根号优化**

我们有两种不同的方法，分别在大数据和小数据下时间复杂度表现良好，把数据分开暴力。


**bitset 优化的01背包**

bitset其实不能优化时间复杂度，但是bitset可以优化一点常数，从 $O(n)变成O(n/k)$特别是当 $W$特别大的时候, 本题的 $W$ 是 $2\times10^5$ 级别的 

没有bitset， 就是 $W  \times k$

```c++
for (i = W; i >= w[i]; --i) {
    dp[i] = dp[i] || dp[i - w[i]];
}
```

bitset过程如下：

```
dp = dp | dp >> w[i]
```

这里dp是一个bitset，每一位表示对应的容量，假设初始的时候我们的最大 $W$ 是 9
那我们初始bitset,

我们假设容量0和5是可达的

```cpp
biset<10> dp;
# dp: 1000010000
```

此时，我们选取到 $w_i$ = 3 , 开始更新状态，

因为容量5对应的第六个位置是1，我们把容量为 $5$ 的背包加上 $w_i = 3$ 之后的背包容量是8，就相当于我们把容量 $5$ 的那个位置的 $true$ 右移了三位, 把 容量为 $8$D 

```cpp
              0123456789

# dp >> w[i]: 0001000010 
# dp:         1000001000
# newdp       1001001000 
dp = dp | dp >> w[i]
```

一直这样遍历下去就可以了

**多重背包剪枝(根号优化背包)**


https://blog.csdn.net/hmc0411/article/details/78483628

